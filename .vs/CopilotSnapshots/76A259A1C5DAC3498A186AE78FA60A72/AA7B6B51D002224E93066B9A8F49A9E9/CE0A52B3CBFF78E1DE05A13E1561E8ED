#include "game.h"
#include "surface.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

namespace Tmpl8
{
    void Game::Init() {}
    void Game::Shutdown() {}

    Surface tiles("assets/tile sprites game buas.png");
    
    int spritesheetWidth = 521;
    int tileSize = 64;
    int spritesheetSpace = 1;
    int mapHeight = 8;
    int mapWidth = 10;

    char map[8][40] = {
         "aax aax aax aax aax aax aax aax aax aax",
         "aax aax eb- ha- hd- ha- hb- aax aax aax",
         "aax aax ga- aax aax aax ga- aax aax aax",
         "aax aax ed- aax aax aax gd- aax aax aax",
         "aax eb- aa- hb- aax aax ga- aax aax aax",
         "aax bb- aa- aa- fd- ha- gb- aax aax aax",
         "aax fb- cb- gb- aax aax aax aax aax aax",
         "aax aax aax aax aax aax aax aax aax aax"
    };

    char overlaymap[8][30] = {
         "da da da da da da da da da da",
         "da da da da ah da da da da da",
         "da da da da da da da da da da",
         "da da bg da da da hg da da da",
         "da da da da da da da da da da",
         "da da da da cg da da da da da",
         "da da da da da da da da da da",
         "da da da da da da da da da da"
    };

    Sprite character(new Surface("assets/character sprites.png"), 4);
    int px = 144, py = 336;

    bool CheckPos(int x, int y)
    {
        int tx = x / tileSize, ty = y / tileSize;
        return map[ty][tx * 4 + 2] != 'x';
    }

    bool stickUnlocked = false;
    int characterState = 0;

    void DrawTile(int tx, int ty, Surface* screen, int x, int y)
    {
        Pixel* src = tiles.GetBuffer() + 1 + tx * (tileSize + spritesheetSpace) + (1 + ty * (tileSize + spritesheetSpace)) * spritesheetWidth;
        Pixel* dst = screen->GetBuffer() + x + y * 800;
        for (int i = 0; i < tileSize; i++, src += spritesheetWidth, dst += 800)
            for (int j = 0; j < tileSize; j++)
                dst[j] = src[j];
    }

    void Game::Tick(float deltaTime)
    {
        screen->Clear(0);
        for (int y = 0; y < mapHeight; y++)
            for (int x = 0; x < mapWidth; x++)
            {
                int tx = map[y][x * 4] - 'a';
                int ty = map[y][x * 4 + 1] - 'a';
                DrawTile(tx, ty, screen, x * tileSize, y * tileSize);
            }

        for (int y = 0; y < mapHeight; y++)
            for (int x = 0; x < mapWidth; x++)
            {
                int tx = overlaymap[y][x * 3] - 'a';
                int ty = overlaymap[y][x * 3 + 1] - 'a';
                DrawTile(tx, ty, screen, x * tileSize, y * tileSize);
            }

        character.Draw(screen, px, py);
        int nx = px, ny = py;
        if (GetAsyncKeyState(VK_LEFT)) nx--;
        if (GetAsyncKeyState(VK_RIGHT)) nx++;
        if (GetAsyncKeyState(VK_UP)) ny--;
        if (GetAsyncKeyState(VK_DOWN)) ny++;
        if (CheckPos(nx, ny) && CheckPos(nx + 30, ny + 30) &&
            CheckPos(nx + 30, ny) && CheckPos(nx, ny + 30))
            px = nx, py = ny;
        
        // character switching
        if (GetAsyncKeyState('C')) {
            character.SetFrame(0);
            characterState = 0;
        }
        if (GetAsyncKeyState('V')) {
            character.SetFrame(2);
            characterState = 2;
        }
        if (GetAsyncKeyState('B')) {
            character.SetFrame(1);
            characterState = 1;
        }
        if (GetAsyncKeyState('N') && stickUnlocked == true) {
            character.SetFrame(3);
            characterState = 3;
        }
    }
};