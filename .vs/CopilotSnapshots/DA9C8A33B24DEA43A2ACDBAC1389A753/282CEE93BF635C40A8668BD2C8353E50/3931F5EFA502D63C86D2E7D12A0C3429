#include "game.h"
#include "surface.h"
#include "cmath"
#include <algorithm>
#include <vector>
#include <string>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

namespace Tmpl8
{
    void Game::Init() {}
    void Game::Shutdown() {}

    Surface tiles("assets/tiles.png");
    
    int spritesheetWidth = 261;
    int tileSize = 64;
    int spritesheetSpace = 1;
    int mapHeight = 8;
    int mapWidth = 8;
    int characterSize = 40;
    int characterCenter = characterSize / 2;
    int level = 0;
    int money = 0;
    bool stickUnlocked = true;
    int characterState = 0;

    bool eIsPressed = false;

    bool holdingItem = false; // is the player holding an item
    int itemHolding = -1; //what item is the player holding

    int dA = 4; //door amount
    int iA = 2; //item amount

    std::vector<int> dX = { tileSize * 3 - tileSize, tileSize * 5 - tileSize, tileSize * 7 - tileSize, tileSize * 5 - tileSize }; //door x
    std::vector<int> dY = { tileSize * 4 - tileSize, tileSize * 2 - tileSize, tileSize * 4 - tileSize, tileSize * 6 - tileSize }; //door y
    std::vector<int> dC = { 1, 3, 2, 6 }; //0 is no criteria, 1-4 is character criteria, 5-10 is key criteria (see doorsprite for order)
    std::vector<bool> dL = { true, true, true, true }; //is the door locked
    std::vector<bool> dO = { false, false, false, false }; //is the door opened
    std::vector<int> dF = { 4, 15, 10, 25 }; //door frame
    std::vector<int> dFu = { 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40 }; //door frames that define an up door
    std::vector<int> dFl = { 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41 }; //door frames that define a left door
    std::vector<int> dFd = { 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42 }; //door frames that define a down door
    std::vector<int> dFr = { 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43 }; //door frames that define a right door

    std::vector<int> iX = { tileSize * 7 - tileSize, tileSize * 3 - tileSize }; //item x
    std::vector<int> iY = { tileSize * 6 - tileSize, tileSize * 6 - tileSize }; //item y
    int iF[2] = { 3, 1 }; //item frame
    std::vector<bool> iPU = { false, false }; //is the item picked up
    std::vector<bool> iU = { false, false }; //is the item used
    std::vector<bool> iH = { false, true }; //is the item hidden

    std::vector<int> tutX = { tileSize * 1 - tileSize, tileSize * 1 - tileSize, tileSize * 4 - tileSize, tileSize * 8 - tileSize, tileSize * 5 - tileSize, tileSize * 1 - tileSize }; //tutorial text baloon x
    std::vector<int> tutY = { tileSize * 3 - tileSize, tileSize * 3 - tileSize, tileSize * 1 - tileSize, tileSize * 4 - tileSize, tileSize * 7 - tileSize, tileSize * 5 - tileSize }; //tutorial text baloon y
    std::vector<int> tutF = { 0, 1, 2, 3, 4, 5 }; //tutorial text baloon frame
    std::vector<bool> tutH = { true, true, true, true, true, true }; //is the tutorial text baloon hidden

    std::vector<std::string> map = {
         "aax aax aax aax aax aax aax aax",
         "aax aax ad- bb- bb- bb- dd- aax",
         "aax aax ab- aax aax aax ab- aax",
         "aax aax ab- aax aax aax ab- aax",
         "aax ad- dg- dd- aax aax ab- aax",
         "aax bc- aa- cg- bb- bb- cd- aax",
         "aax bd- cc- cd- aax aax aax aax",
         "aax aax aax aax aax aax aax aax"
    };

    Sprite character(new Surface("assets/character sprites.png"), 4);
    int px = (tileSize * 3 - tileSize) + ((tileSize - characterSize) / 2), py = (tileSize * 6 - tileSize) + ((tileSize - characterSize) / 2);

    Sprite doors(new Surface("assets/doors.png"), 44);
    Sprite items(new Surface("assets/items.png"), 8);
    Sprite tutorial(new Surface("assets/tutorial.png"), 6);

    //overgangen
    Sprite CtB(new Surface("assets/cube to ball.png"), 9);
    Sprite CtT(new Surface("assets/cube to triangle.png"), 10);
    Sprite CtS(new Surface("assets/cube to stickfigure.png"), 11);

    Sprite BtC(new Surface("assets/ball to cube.png"), 90);
    Sprite BtT(new Surface("assets/ball to triangle.png"), 7);
    Sprite BtS(new Surface("assets/ball to stickfigure.png"), 11);

    Sprite TtC(new Surface("assets/triangle to cube.png"), 10);
    Sprite TtB(new Surface("assets/triangle to ball.png"), 7);
    Sprite TtS(new Surface("assets/triangle to stickfigure.png"), 11);

    Sprite StC(new Surface("assets/stickfigure to cube.png"), 11);
    Sprite StB(new Surface("assets/stickfigure to ball.png"), 11);
    Sprite StT(new Surface("assets/stickfigure to triangle.png"), 11);


    bool CheckPos(int x, int y)
    {
        int tx = x / tileSize, ty = y / tileSize;
        return map[ty][tx * 4 + 2] != 'x';
    }

    /*void createlevel()
    {
        if (level == 0)
        {
            iA = 1;

        }

    }*/


    void DrawTile(int tx, int ty, Surface* screen, int x, int y)
    {
        if (x >= screen->GetWidth() - tileSize || x < 0 || y >= screen->GetHeight() - tileSize || y < 0) return;
        Pixel* src = tiles.GetBuffer() + 1 + tx * (tileSize + spritesheetSpace) + (1 + ty * (tileSize + spritesheetSpace)) * spritesheetWidth;
        Pixel* dst = screen->GetBuffer() + x + y * 800;
        for (int i = 0; i < tileSize; i++, src += spritesheetWidth, dst += 800)
            for (int j = 0; j < tileSize; j++)
                dst[j] = src[j];
    }

    void checkItem(int px, int py)
    {
        for (int i = 0; i < iA; i++)
        {
            if (px + characterCenter >= iX[i] && px + characterCenter <= iX[i] + 64 && py + characterCenter >= iY[i] && py + characterCenter <= iY[i] + 64 && iH[i] == false && iU[i] == false)
            {
                if (itemHolding != i)
                {
                    if (iF[i] == 0)
                    {
                        iPU[i] = true;
                        money++;
                        return;
                    }
                    else if (holdingItem == false)
                    {
                        iPU[i] = true;
                        itemHolding = i;
                        holdingItem = true;
                        return;
                    }
                    else if (holdingItem == true)
                    {
                        // dropping previous item at this item's position
                        int prev = itemHolding;
                        iX[prev] = iX[i];
                        iY[prev] = iY[i];
                        iPU[prev] = false;
                        // picking up new item
                        iPU[i] = true;
                        itemHolding = i;
                        holdingItem = true;
                        return;
                    }
                    
                }
            }
            if (itemHolding == i)
            {
                int prev = itemHolding;
                iX[prev] = floor((px + characterCenter) / tileSize) * tileSize;
                iY[prev] = floor((py + characterCenter) / tileSize) * tileSize;
                iPU[prev] = false;
                holdingItem = false;
                itemHolding = -1;
            }
        }
    }

    bool checkDoor(int nx, int ny)
    {
        for (int i = 0; i < dA; i++)
        {
            if (dC[i] < 5 && dC[i] > 0 && dC[i] != (characterState + 1))
            {
                dL[i] = true;
            }
            else if (dC[i] < 5 && dC[i] > 0 && dC[i] == (characterState + 1))
            {
                dL[i] = false;
            }

            if (dC[i] >= 5 && dC[i] == (iF[itemHolding] + 3) && dL[i] == true && nx + characterCenter >= dX[i] && nx + characterCenter <= dX[i] + 64 && ny + characterCenter >= dY[i] && ny + characterCenter <= dY[i] + 64)
            {
                dL[i] = false;
                iU[itemHolding] = true;
                holdingItem = false;
                itemHolding = -1;
            }

            //open door when unlocked
            if (dL[i] == false && dO[i] == false)
            {
                for (int j = 0; j < 11; j++)
                {
                    if (dF[i] == dFu[j])
                    {
                        dF[i] = dF[i] + 1;
                        dO[i] = true;
                    }
                    else if (dF[i] == dFl[j])
                    {
                        dF[i] = dF[i] + 1;
                        dO[i] = true;
                    }
                    else if (dF[i] == dFd[j])
                    {
                        dF[i] = dF[i] + 1;
                        dO[i] = true;
                    }
                    else if (dF[i] == dFr[j])
                    {
                        dF[i] = dF[i] - 3;
                        dO[i] = true;
                    }
                }
            }
            //close door when locked
            if (dL[i] == true && dO[i] == true)
            {
                for (int j = 0; j < 11; j++)
                {
                    if (dF[i] == dFu[j])
                    {
                        dF[i] = dF[i] + 3;
                        dO[i] = false;
                    }
                    else if (dF[i] == dFl[j])
                    {
                        dF[i] = dF[i] - 1;
                        dO[i] = false;
                    }
                    else if (dF[i] == dFd[j])
                    {
                        dF[i] = dF[i] - 1;
                        dO[i] = false;
                    }
                    else if (dF[i] == dFr[j])
                    {
                        dF[i] = dF[i] - 1;
                        dO[i] = false;
                    }
                }
            }

            if (dL[i] == true)
            {
                for (int j = 0; j < 11; j++)
                {
                    //doors up
                    if (dF[i] == dFu[j] && nx + characterSize >= dX[i] && nx <= dX[i] + 64 && ny + characterSize >= dY[i] && ny <= dY[i] + 12)
                    {
                        return false;
                    }
                    //doors left
                    else if (dF[i] == dFl[j] && nx + characterSize >= dX[i] && nx <= dX[i] + 12 && ny >= dY[i] && ny <= dY[i] + 64)
                    {
                        return false;
                    }
                    //doors down
                    else if (dF[i] == dFd[j] && nx >= dX[i] && nx <= dX[i] + 64 && ny + characterSize >= dY[i] + 52 && ny <= dY[i] + 64)
                    {
                        return false;
                    }
                    //doors right
                    else if (dF[i] == dFr[j] && nx + characterSize >= dX[i] + 52 && nx <= dX[i] + 64 && ny >= dY[i] && ny <= dY[i] + 64)
                    {
                        return false;
                    }
                }
            }
        }
        if (level == 0 && dL[3] == false) iH[1] = false;
        return true;
    }

    void createLevel(Surface* screen,int startmidX,int startmidY, int px, int py)
    {
        if (level == 1)
        {
            dA = 4;
            /*map[8][40] = {
            "aax aax aax aax aax aax aax aax aax aax",
            "aax aax ad- bb- bb- bb- dd- aax aax aax",
            "aax aax ab- aax aax aax ab- aax aax aax",
            "aax aax ab- aax aax aax ab- aax aax aax",
            "aax ad- dg- dd- aax aax ab- aax aax aax",
            "aax bc- aa- cg- bb- bb- cd- aax aax aax",
            "aax bd- cc- cd- aax aax aax aax aax aax",
            "aax aax aax aax aax aax aax aax aax aax"
            };*/
        }

        //doors creation
        for (int i = 0; i < dA; i++)
        {
            doors.SetFrame(dF[i]);
            doors.Draw(screen, dX[i] - px + startmidX, dY[i] - py + startmidY);
        }
    }

    void tutorialCheck(int px, int py)
    {
        px = px + characterCenter;
        py = py + characterCenter;
        for (int i = 0; i < 6; i++) { tutH[i] = true; }
        if (level == 0)
        {
            if (px >= tileSize * 3 - tileSize && px <= tileSize * 4 - tileSize && py >= tileSize * 6 - tileSize && py <= tileSize * 7 - tileSize && iH[1] == true) tutH[0] = false;
            else if (px >= tileSize * 3 - tileSize && px <= tileSize * 4 - tileSize && py >= tileSize * 4 - tileSize && py <= tileSize * 6 - tileSize && iH[1] == true) tutH[1] = false;
            else if (px >= tileSize * 4 - tileSize && px <= tileSize * 6 - tileSize && py >= tileSize * 2 - tileSize && py <= tileSize * 3 - tileSize && iH[1] == true) tutH[2] = false;
            else if (px >= tileSize * 7 - tileSize && px <= tileSize * 8 - tileSize && py >= tileSize * 3 - tileSize && py <= tileSize * 5 - tileSize && iH[1] == true) tutH[3] = false;
            else if (px >= tileSize * 5 - tileSize && px <= tileSize * 7 - tileSize && py >= tileSize * 6 - tileSize && py <= tileSize * 7 - tileSize && iH[1] == true) tutH[4] = false;
            else if (px >= tileSize * 2 - tileSize && px <= tileSize * 5 - tileSize && py >= tileSize * 5 - tileSize && py <= tileSize * 8 - tileSize && iH[1] == false) tutH[5] = false;
        }
        else
        {
            return;
        }
    }


    void Game::Tick(float deltaTime)
    {
        int startmidX = (screen->GetWidth() - 32) / 2;
        int startmidY = (screen->GetHeight() - 32) / 2;

        screen->Clear(0);
        for (int y = 0; y < mapHeight; y++)
            for (int x = 0; x < mapWidth; x++)
            {
                int tx = map[y][x * 4] - 'a';
                int ty = map[y][x * 4 + 1] - 'a';
                DrawTile(tx, ty, screen, x * tileSize - px + startmidX, y * tileSize - py + startmidY);
            }

        // draw doors after clearing and drawing the map so they are not immediately erased
        createLevel(screen, startmidX, startmidY, px, py);
        
        character.Draw(screen, startmidX, startmidY);
        int nx = px, ny = py;
        if (GetAsyncKeyState(VK_LEFT) || GetAsyncKeyState('A')) {
            nx--;
            nx--;
        }
        if (GetAsyncKeyState(VK_RIGHT) || GetAsyncKeyState('D')) {
            nx++;
            nx++;
        }
        if (GetAsyncKeyState(VK_UP) || GetAsyncKeyState('W')) {
            ny--;
            ny--;
        }
        if (GetAsyncKeyState(VK_DOWN) || GetAsyncKeyState('S')) {
            ny++;
            ny++;
        }
        if (CheckPos(nx, ny) && CheckPos(nx + 40, ny + 40) && CheckPos(nx + 40, ny) && CheckPos(nx, ny + 40) &&
            checkDoor(nx, ny))
            px = nx, py = ny;
        
        tutorialCheck(px, py);
        

        //item creation
        for (int i = 0; i < iA; i++)
        {
            if (iPU[i] == false && iU[i] == false && iH[i] == false)
            {
                items.SetFrame(iF[i]);
                items.Draw(screen, iX[i] - px + startmidX, iY[i] - py + startmidY);
            }
        }

        //tutorial creation
        for (int i = 0; i < 6; i++)
        {
            if (tutH[i] == false)
            {
                tutorial.SetFrame(tutF[i]);
                tutorial.Draw(screen, tutX[i] - px + startmidX, tutY[i] - py + startmidY);
            }
        }


        if (GetAsyncKeyState('E'))
        {
            if (eIsPressed == false)
            {
                checkItem(px, py);
                eIsPressed = true;
            }
        }
        else
        {
            eIsPressed = false;
        }


        // character switching
        if (GetAsyncKeyState('C')) {
            if (characterState == 1) {
                for (int i = 0; i < 90; i++) {
                    BtC.SetFrame(i);
                }
            }
            else if (characterState == 2) {
                for (int i = 0; i < 100; i++) {
                    TtC.SetFrame(i);
                }
            }
            else if (characterState == 3) {
                for (int i = 0; i < 110; i++) {
                    StC.SetFrame(i);
                }
            }
            character.SetFrame(0);
            characterState = 0;
        }
        if (GetAsyncKeyState('B')) {
            if (characterState == 0) {
                for (int i = 0; i < 90; i++) {
                    CtB.SetFrame(i);
                }
            }
            else if (characterState == 2) {
                for (int i = 0; i < 70; i++) {
                    TtB.SetFrame(i);
                }
            }
            else if (characterState == 3) {
                for (int i = 0; i < 110; i++) {
                    StB.SetFrame(i);
                }
            }
            character.SetFrame(1);
            characterState = 1;
        }
        if (GetAsyncKeyState('V')) {
            if (characterState == 0) {
                for (int i = 0; i < 100; i++) {
                    CtT.SetFrame(i);
                }
            }
            else if (characterState == 1) {
                for (int i = 0; i < 70; i++) {
                    BtT.SetFrame(i);
                }
            }
            else if (characterState == 3) {
                for (int i = 0; i < 110; i++) {
                    StT.SetFrame(i);
                }
            }
            character.SetFrame(2);
            characterState = 2;
        }
        if (GetAsyncKeyState('N') && stickUnlocked == true) {
            if (characterState == 0) {
                for (int i = 0; i < 110; i++) {
                    CtS.SetFrame(i);
                }
            }
            else if (characterState == 1) {
                for (int i = 0; i < 110; i++) {
                    BtS.SetFrame(i);
                }
            }
            else if (characterState == 2) {
                for (int i = 0; i < 110; i++) {
                    TtS.SetFrame(i);
                }
            }
            character.SetFrame(3);
            characterState = 3;
        }
    }
};