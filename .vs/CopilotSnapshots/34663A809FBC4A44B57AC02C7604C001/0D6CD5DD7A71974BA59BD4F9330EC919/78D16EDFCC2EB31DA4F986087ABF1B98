#include "game.h"
#include "surface.h"
#include "cmath"
#include <algorithm>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

namespace Tmpl8
{
    void Game::Init() {}
    void Game::Shutdown() {}

    Surface tiles("assets/tiles.png");
    
    int spritesheetWidth = 261;
    int tileSize = 64;
    int spritesheetSpace = 1;
    int mapHeight = 8;
    int mapWidth = 10;
    int characterSize = 40;
    int characterCenter = characterSize / 2;
    int level = 0;
    int money = 0;

    bool eIsPressed = false;

    bool holdingItem = false; // is the player holding an item
    int itemHolding = -1; //what item is the player holding

    int dA = 4; //door amount
    int iA = 2; //item amount

    int dX[4] = { tileSize * 3 - tileSize, tileSize * 5 - tileSize, tileSize * 7 - tileSize, tileSize * 5 - tileSize }; //door x
    int dY[4] = { tileSize * 4 - tileSize, tileSize * 2 - tileSize, tileSize * 4 - tileSize, tileSize * 6 - tileSize }; //door y
    int dC[4] = { 1, 3, 2, 6 }; //0 is no criteria, 1-4 is character criteria, 5-10 is key criteria (see doorsprite for order)
    int dF[4] = { 4, 15, 10, 25 }; //door frame
    int dFu[11] = { 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40 }; //door frames that define an up door
    int dFl[11] = { 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41 }; //door frames that define a left door
    int dFd[11] = { 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42 }; //door frames that define a down door
    int dFr[11] = { 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43 }; //door frames that define a right door

    int iX[2] = { tileSize * 7 - tileSize, tileSize * 7 - tileSize }; //item x
    int iY[2] = { tileSize * 6 - tileSize, tileSize * 2 - tileSize }; //item y
    int iF[2] = { 3, 0 }; //item frame
    bool iPU[2] = { false, false }; //is the item picked up
    bool iU[2] = { false, false }; //is the item used

    char map[8][40] = {
         "aax aax aax aax aax aax aax aax aax aax",
         "aax aax ad- bb- bb- bb- dd- aax aax aax",
         "aax aax ab- aax aax aax ab- aax aax aax",
         "aax aax ab- aax aax aax ab- aax aax aax",
         "aax ad- dg- dd- aax aax ab- aax aax aax",
         "aax bc- aa- cg- bb- bb- cd- aax aax aax",
         "aax bd- cc- cd- aax aax aax aax aax aax",
         "aax aax aax aax aax aax aax aax aax aax"
    };

    Sprite character(new Surface("assets/character sprites.png"), 4);
    int px = (tileSize * 3 - tileSize) + ((tileSize - characterSize) / 2), py = (tileSize * 6 - tileSize) + ((tileSize - characterSize) / 2);

    Sprite doors(new Surface("assets/doors.png"), 44);
    Sprite items(new Surface("assets/items.png"), 8);

    //overgangen
    Sprite CtB(new Surface("assets/cube to ball.png"), 9);
    Sprite CtT(new Surface("assets/cube to triangle.png"), 10);
    Sprite CtS(new Surface("assets/cube to stickfigure.png"), 11);

    Sprite BtC(new Surface("assets/ball to cube.png"), 90);
    Sprite BtT(new Surface("assets/ball to triangle.png"), 7);
    Sprite BtS(new Surface("assets/ball to stickfigure.png"), 11);

    Sprite TtC(new Surface("assets/triangle to cube.png"), 10);
    Sprite TtB(new Surface("assets/triangle to ball.png"), 7);
    Sprite TtS(new Surface("assets/triangle to stickfigure.png"), 11);

    Sprite StC(new Surface("assets/stickfigure to cube.png"), 11);
    Sprite StB(new Surface("assets/stickfigure to ball.png"), 11);
    Sprite StT(new Surface("assets/stickfigure to triangle.png"), 11);


    bool CheckPos(int x, int y)
    {
        int tx = x / tileSize, ty = y / tileSize;
        return map[ty][tx * 4 + 2] != 'x';
    }

    /*void createlevel()
    {
        if (level == 0)
        {
            iA = 1;

        }

    }*/

    bool stickUnlocked = true;
    int characterState = 0;

    void DrawTile(int tx, int ty, Surface* screen, int x, int y)
    {
        Pixel* src = tiles.GetBuffer() + 1 + tx * (tileSize + spritesheetSpace) + (1 + ty * (tileSize + spritesheetSpace)) * spritesheetWidth;
        Pixel* dst = screen->GetBuffer() + x + y * 800;
        for (int i = 0; i < tileSize; i++, src += spritesheetWidth, dst += 800)
            for (int j = 0; j < tileSize; j++)
                dst[j] = src[j];
    }

    void checkItem(int px, int py)
    {
        for (int i = 0; i < iA; i++)
        {
            if (px + characterCenter >= iX[i] && px + characterCenter <= iX[i] + 64 && py + characterCenter >= iY[i] && py + characterCenter <= iY[i] + 64)
            {
                if (itemHolding != i)
                {
                    if (iF[i] == 0)
                    {
                        iPU[i] = true;
                        money++;
                        return;
                    }
                    else if (holdingItem == false)
                    {
                        iPU[i] = true;
                        itemHolding = i;
                        holdingItem = true;
                        return;
                    }
                    else if (holdingItem == true)
                    {
                        // dropping previous item at this item's position
                        int prev = itemHolding;
                        iX[prev] = iX[i];
                        iY[prev] = iY[i];
                        iPU[prev] = false;
                        // picking up new item
                        iPU[i] = true;
                        itemHolding = i;
                        holdingItem = true;
                        return;
                    }
                    
                }
            }
            if (itemHolding == i)
            {
                int prev = itemHolding;
                iX[prev] = floor((px + characterCenter) / tileSize) * tileSize;
                iY[prev] = floor((py + characterCenter) / tileSize) * tileSize;
                iPU[prev] = false;
                holdingItem = false;
                itemHolding = -1;
            }
        }
    }

    bool checkDoor(int nx, int ny)
    {
        for (int i = 0; i < dA; i++)
        {
            if (dC[i] < 5 && dC[i] > 0 && dC[i] != (characterState + 1) || dC[i] >= 5 && dC[i] != (itemHolding + 3))
            {
                for (int j = 0; j < 44; j++)
                {
                    //doors up
                    if (dF[i] == dFu[j])
                    {
                        if (nx >= dX[i] && nx <= dX[i] + 64 && ny >= dY[i] && ny <= dY[i] + 12)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    //doors left
                    else if (dF[i] == dFl[j])
                    {
                        if (nx >= dX[i] && nx <= dX[i] + 12 && ny >= dY[i] && ny <= dY[i] + 64)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    //doors down
                    else if (dF[i] == dFd[j])
                    {
                        if (nx >= dX[i] && nx <= dX[i] + 64 && ny + characterSize >= dY[i] + 52 && ny <= dY[i] + 64)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    //doors right
                    else if (dF[i] == dFr[j])
                    {
                        if (nx + characterSize >= dX[i] + 52 && nx <= dX[i] + 64 && ny >= dY[i] && ny <= dY[i] + 64)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                }
            }                                 
        }
    }

    void Game::Tick(float deltaTime)
    {
        screen->Clear(0);
        for (int y = 0; y < mapHeight; y++)
            for (int x = 0; x < mapWidth; x++)
            {
                int tx = map[y][x * 4] - 'a';
                int ty = map[y][x * 4 + 1] - 'a';
                DrawTile(tx, ty, screen, x * tileSize, y * tileSize);
            }

        //doors creation
        for (int i = 0; i < dA; i++)
        {
            doors.SetFrame(dF[i]);
            doors.Draw(screen, dX[i], dY[i]);
        }

        character.Draw(screen, px, py);
        int nx = px, ny = py;
        if (GetAsyncKeyState(VK_LEFT) || GetAsyncKeyState('A')) {
            nx--;
            nx--;
        }
        if (GetAsyncKeyState(VK_RIGHT) || GetAsyncKeyState('D')) {
            nx++;
            nx++;
        }
        if (GetAsyncKeyState(VK_UP) || GetAsyncKeyState('W')) {
            ny--;
            ny--;
        }
        if (GetAsyncKeyState(VK_DOWN) || GetAsyncKeyState('S')) {
            ny++;
            ny++;
        }
        if (CheckPos(nx, ny) && CheckPos(nx + 40, ny + 40) && CheckPos(nx + 40, ny) && CheckPos(nx, ny + 40) &&
            checkDoor(nx, ny))
            px = nx, py = ny;
        
        

        //doors creation
        for (int i = 0; i < iA; i++)
        {
            if (iPU[i] == false && iU[i] == false)
            {
                items.SetFrame(iF[i]);
                items.Draw(screen, iX[i], iY[i]);
            }
        }


        if (GetAsyncKeyState('E'))
        {
            if (eIsPressed == false)
            {
                checkItem(px, py);
                eIsPressed = true;
            }
        }
        else
        {
            eIsPressed = false;
        }


        // character switching
        if (GetAsyncKeyState('C')) {
            if (characterState == 1) {
                for (int i = 0; i < 9; i++) {
                    BtC.SetFrame(0 + i);
                }
            }
            if (characterState == 2) {
                for (int i = 0; i < 10; i++) {
                    TtC.SetFrame(0 + i);
                }
            }
            if (characterState == 3) {
                for (int i = 0; i < 11; i++) {
                    StC.SetFrame(0 + i);
                }
            }
            character.SetFrame(0);
            characterState = 0;
        }
        if (GetAsyncKeyState('B')) {
            if (characterState == 0) {
                for (int i = 0; i < 9; i++) {
                    CtB.SetFrame(0 + i);
                }
            }
            if (characterState == 2) {
                for (int i = 0; i < 7; i++) {
                    TtB.SetFrame(0 + i);
                }
            }
            if (characterState == 3) {
                for (int i = 0; i < 11; i++) {
                    StB.SetFrame(0 + i);
                }
            }
            character.SetFrame(1);
            characterState = 1;
        }
        if (GetAsyncKeyState('V')) {
            if (characterState == 0) {
                for (int i = 0; i < 10; i++) {
                    CtT.SetFrame(0 + i);
                }
            }
            if (characterState == 1) {
                for (int i = 0; i < 7; i++) {
                    BtT.SetFrame(0 + i);
                }
            }
            if (characterState == 3) {
                for (int i = 0; i < 11; i++) {
                    StT.SetFrame(0 + i);
                }
            }
            character.SetFrame(2);
            characterState = 2;
        }
        if (GetAsyncKeyState('N') && stickUnlocked == true) {
            if (characterState == 0) {
                for (int i = 0; i < 11; i++) {
                    CtS.SetFrame(0 + i);
                }
            }
            if (characterState == 1) {
                for (int i = 0; i < 11; i++) {
                    BtS.SetFrame(0 + i);
                }
            }
            if (characterState == 2) {
                for (int i = 0; i < 11; i++) {
                    TtS.SetFrame(0 + i);
                }
            }
            character.SetFrame(3);
            characterState = 3;
        }
    }
};